# 进程

## 虚拟化

将逻辑上的资源映射到物理资源上, 使得多个进程的逻辑资源相互独立

## 程序和进程

程序是静态的文件, 进程是动态的程序实例

不同的进程之间, 由操作系统进行资源调度, 使得多个任务可以并发执行

## 虚拟化的技术

- 时间复用: 将时间划分为多个时间片, 每个时间片内只能执行一个进程, 但是在不同的时间片内, 进程来回切换, 使得多个进程可以并发执行
- 空间复用: 每个进程都有自己的虚拟地址空间, 使得多个进程的地址空间相互独立
- 调度算法:
  - Round Robin: 时间片轮转
  - 运行时间短的优先
- 进程的上下文: 进程的运行状态, 寄存器的值, 进程的堆栈, 进程的虚拟地址空间等等

## 进程

- 创建进程: 将代码和静态数据加载到内存中, 创建堆栈
- 进程状态:
  - **就绪**: 进程已经准备好, 等待被调度, 即**运行状态**
  - **运行**: 进程正在运行, 可以转换为**阻塞状态**或者**就绪状态**
  - **阻塞**: 进程等待某个事件发生, 例如等待 IO, 等待完成后, 可以转换为**就绪状态**
- 数据结构
  - PCB: 进程控制块, 记录进程的状态, 进程的上下文, 进程的资源等等
  - 进程队列: 记录所有进程的状态, 例如就绪队列, 阻塞队列等等

## 进程 API

- `fork`: 创建子进程
- `execvp`: 加载并执行一个新的程序
- `wait`: 等待子进程结束

## 系统调用

通过系统调用从用户态切换到内核态, 从而执行内核态的代码

## 进程切换

- 方式一: 等待进程的系统调用, 然后切换进程
- 方式二: 操作系统定期发生时钟中断, 然后切换进程
- 切换手段: 保存当前进程的上下文, 加载下一个进程的上下文

# 调度

## 调度指标

- 周转时间: 从进程开始运行到进程结束运行的时间, 等于**完成时间**减去**到达时间**
- 响应时间: 任务从到达系统到首次运行的时间, 等于**首次运行**时间减去**到达时间**

## 调度算法

### 先进先出(FIFO)

按照进程到达的顺序进行调度, 不允许抢占

### 短作业优先(SJF)

按照进程的运行时间进行调度, 不允许抢占

### 最短完成时间优先(STCF)

在**SJF**的基础上, 允许抢占

### 轮转调度(RR)

让所有进程轮流执行, 每个进程执行一个**时间片**, 然后切换到下一个进程

时间片过长会导致响应时间过长, 时间片过短会导致进程切换过于频繁

### 考虑 IO

当一个进程等待 IO 时, 可以切换到下一个进程, 从而提高 CPU 的利用率

### 多级反馈队列调度(MLFQ)

**MLFQ**有多个队列, 每个队列的优先级不同, 一个工作只能存在于一个队列中

- **MFLQ**总是在最高优先级的队列中调度, 同一个队列中, 采用**RR**调度算法
- 工作进入系统时, 会被放入**最高优先级**的队列中
- 一旦工作用完了其在某一层中的时间配额, 无论中间主动放弃了多少次 CPU, 都会被放入**下一个优先级**的队列中
  - 防止程序伪装成交互型程序
- 每隔一段时间$S$, 会将**所有工作**放入**最高优先级**的队列中
  - 为了防止进程饥饿
- 通常优先级越低, 时间片越长

## 多处理器调度

- 并发访问问题: 两个进程同时访问同一个资源, 如果不加锁, 会导致数据不一致
- 缓存亲和度: 一个进程在多个 CPU 上运行, 会导致缓存多次重复加载, 减缓运行速度

### 单队列调度(SQMS)

所有进程都放在一个队列中, 可能造成**缓存亲和度**问题

### 多队列调度(MQMS)

每个 CPU 有一个队列, 进程只能在一个队列中, 可能造成**负载不均衡**的问题, 可以通过**迁移进程**来解决