# 网络层: 路由协议

## 逐跳路由

从源到目的地的路径由**途中的节点**共同维护

假设 S 到 D 的路径: S->R1->R2->...->Rn->D

- 每个节点只需要维护到目的地的**下一跳节点**信息即可
- 可能短暂出现路由**回路**
- 单播(unicast)路由: 单个目的节点
- 多播(组播, multicast)路由: 一个或者多个源发送分组给多个目的节点, 多个节点共同维护一棵组播树

### 路由算法

**扩散法**: 将收到的分组向除到来链路外的**所有其他链路**转发

通过以下方式抑制重复分组:

- 节点计数器: 源端在分组头部包含一个节点计数器, 每到达一个节点减 1, 为 0 时丢弃, 节点计数器初值可设置为网络的直径
- 记录分组扩散的路径有两种方案
  - 分组头部记录目前**经过的节点列表**, 如果节点本身出现在列表中, 则丢弃
  - 分组头部包含源节点和顺序号, **途中节点**记录收到的分组的源节点和顺序号, 如果分组与节点记录的分组接收信息匹配, 则丢弃
- 选择扩散: 一般要求有地理位置信息, 选择可能向目的节点的方向

**逆向学习法**: 每个分组中包含源节点和经过节点的个数(或者**花费**), 节点接收到分组时，可了解到到源节点方向的**路径花费**，经过一段时间学习到最短路径

- 节点仅记录较好路径的变化，原有最短路径上的节点或者链路崩溃时无法了解到, 需要重新**刷新节点**对当前网络的了解, 即路由表中的路由表项定期超时移走

## 自治系统

Internet 规模大，路由消息、路由表和收敛性都要求采用层次路由, 因此分成多个**自治系统 AS**(Autonomous System), 由一个或者多个独立的管理实体控制的采用**相同路由策略**的网络和路由器组成

自治系统编号(ASN)最初为 16 比特, 64512~65534 为内部自治系统编号, 2007 年 RFC 4893 扩充为 32 比特，X.Y 来表示

自治系统内部选择各自的内部路由协议(IGP), 自治系统之间运行外部路由协议(EGP)

## 链路状态路由

路由器维护本地的**链路状态信息**

为了传播链路状态, 每个节点将其链路状态信息通过**扩散**的方法传播给所有路由器, 每个节点根据了解到的当前全局拓扑采用**Dijkstra 算法**计算路由

路由器定期在链路上发送 Hello 分组来**发现和维护邻居**, Hello 分组给出最近（dead 间隔以内）收听到的发送过 Hello 分组的邻居路由器列表, 如果路由器发现收到的 Hello 分组包含自身路由器的 ID，其到邻居路由器的**双向链路**是相通的

- 考虑到分组可能丢失，dead 间隔期间(n 次 hello 间隔) 只要有 k 次收到，则认为链路相通
- 如果 dead 间隔期间(n 次 hello 间隔)都没有收到 Hello 分组，则认为其已经断开

到邻居节点的花费可通过手工配置或通过测量延迟的方法来获得

### 扩散

每个节点维护一个**链路状态数据库**(LSDB), 包含所有节点的链路状态信息, 每个节点周期性地向所有邻居节点发送**链路状态分组**(LSP), LSP 包含节点的链路状态信息, 每个节点收到 LSP 后更新 LSDB, 通过 LSDB 可以了解到当前网络的全局拓扑

为了避免重复分组, LSP 包含**路由器 ID + 顺序号**, 顺序号越大越新, 每个路由器仅在 LSDB 中维护最新的 LSP, 如果收到的 LSP 顺序号小于等于 LSDB 中的 LSP, 则丢弃

- 顺序号采用循环顺序号
- 设总顺序号个数为$N$, 则当$|a-b|<N/2$且$a<b$时, 或者$|a-b|>N/2$且$a>b$时, 才认为$a$小于$b$

为了避免路由器崩溃或者链路断开造成顺序号错乱, 在 LSP 中增加**年龄**(age)字段，以合适的速度减少 age, age=0 表示 LSP 超时，需要丢弃，不用于路由计算

- LSP 超时时，扩散顺序号相同但 age=0 的 LSP 来通知其他邻居该 LSP 超时
- 如果收到 LSP 的 age 为 0，且顺序号与保存的 LSP 相同时，将保存的 LSP 的 age 设置为 0，然后扩散给其他邻居
- 如果收到新的 LSP 的 age 不为 0，且保存的 LSP 的 age 为 0 时(顺序号不比较)，替换为新的 LSP
- 崩溃重启时等待足够长的时间(超过最大 age)，确保崩溃前发送的 LSP 在其他节点处超时

通过**可靠扩散**可以避免**顺序号回绕**, 即扩散给邻居时要求**确认**

- 最大 age 为 1 个小时以提高效率, 每隔 30 分钟定期产生一个新的 LSP，有变化时产生新的 LSP, 顺序号回绕需要极长的时间
- LSP 初始**age 为 0**，在转发时也会**增加 age**, 在 LSDB 中保存时也会增加，直到等于 MaxAge。此时扩散该 LSP 将其从其他路由器中也清除
- 当路由器 S 的 LSP 顺序号到达最大值时, 应等老的链路状态“过期” ，才能发送新的最小顺序号的 LSP, 可通过扩散顺序号为最大值，但是**age=MaxAge**的 LSP 来清除老的 LSP

#### 可靠扩散优化

收到路由分组后不是马上扩散，而是等待一段时间，丢弃这段时间来的重复和过时的分组，减少负载开销

路由器有 k 个邻居，对于要扩散的每个 LSP，对于每个邻居，维护 2 个标记（共 2k 个标记），分别对应是否要 SEND 到该邻居，是否要发送 ACK 给该邻居, 路由器从 X 收到 S 的 LSP 时:

- 如果顺序号更新，则接受，保存 LSP，设置 ACK X，设置 SEND 给其它路由器
- 如果更老，则忽略
- 如果相等，则设置 ACK X，清除 SEND X

轮流扫描 ACK 和 SEND 标志，发送实际的报文

### 开放最短路径优先协议 OSPF

引入邻接关系的概念, 点到点链路上的邻居关系等同于邻接关系, 广播链路上选取选取路由器 DR（Designated Router），考虑 DR 可能出现故障，还会同时选取备份选取路由 BDR, **只有 DR 和 BDR 与广播链路上的其他路由器有邻接关系**, 链路状态信息只有在邻接关系的路由器间交换, 同时 DR 还负责将 LSA 扩散到其他路由器, DR 和 BDR 通过 Hello 分组来选举

OSPF 支持**层次路由**，进一步划分成多个**区域(area)**, 每个**区域内部**采用各自的链路状态路由协议, **区域间**路由必须通过**主干区域**，限制路由的规模，避免路由回路, **外部**路由通过自治系统边界路由器(**ASBR**)到外部网络

- 区域边界路由器**ABR**连接到多个区域, ABR 必须要连接到主干区域
- 两个 ABR 在主干区域不连通时可以在这两个 ABR 之间建立一条**虚拟链路**, 仅仅作为临时的措施
  - 虚拟链路的路由通过该区域内的路由完成
  - 虚拟链路属于主干区域

#### 各种 LSA

- 第一类 LSA: **路由器 LSA**, 描述路由器周围情况
- 第二类 LSA: **网络 LSA**, 描述广播网络的链路状况
  - 路由器 LSA 和网络 LSA 会在其所在的区域中扩散
- 第三类 LSA: **汇集 LSA**, 用于汇集区域内的链路状态信息, ABR 产生汇集 LSA, 在主干区域中扩散, 再经过其他区域的 ABR 扩散到其他本地区域
  - 到其他区域的网络 N 可以通过本 ABR 到达，其花费=**主干区域中到目的区域某个 ABR 的花费** + **该 ABR 的汇集 LSA 中的花费**
- 第四类 LSA: **ASBR 汇集 LSA**, 类似于第三类
- 第五类 LSA: **AS 外部 LSA**, ASBR 汇总从其他自治系统收到的外部路由信息, 将其扩散到本自治系统中
- 对于**末端区域**, 即没有 ASBR 的本地区域
  - 不需要往该区域扩散 AS 外部 LSA 和 ASBR 汇集 LSA
- 对于**完全末端区域**, 即该区域只有 1 个 ABR，且该区域没有 ASBR
  - 不需要往该区域扩散汇集 LSA、AS 外部 LSA 和 ASBR 汇集 LSA

## 距离向量路由

最优原理：如果节点 A 到节点 B 的最优路由经过了节点 C，则该路由上的 A 到 C 和 C 到 B 分别也是节点 A 和节点 C、节点 C 和节点 B 的最优路由

### Bellman-Ford 算法

$$
d_x(y) = \min_v\{c(x,v)+d_v(y)\}
$$

其中 $c(x,v)$ 为节点 $x$ 到节点 $v$ 的花费, 并且 $v$ 是 $x$ 的邻居, $d_v(y)$ 为节点 $v$ 到节点 $y$ 的最优花费

#### 分布式实现

- 初始时，每个节点只知道自己的邻居节点的花费
- 分布式: 每个节点只需把路由表传递给**直接邻居**
- 异步: 每个节点独立定期发送路由表，或者在拓扑有变化时触发更新，节点间路由交换步骤无需同步
- 迭代:
  - 每个节点收到邻居节点来的路由表后重新计算路由表
  - 迭代计算过程中无需额外的信号来通知结束，迭代过程在没有新的信息更新时自动收敛结束

#### 迭代实现

- 初始时，每个节点只知道自己的邻居节点的花费
- 多次迭代计算:
  - 每个节点根据上一轮计算出来的邻居节点到目的地的花费，确定其到目的地的最短花费
  - 由于节点到 S 的最短距离为非递增的，k 轮计算的距离为最多经过 k 跳的最短路径
- 当最短距离不变的情况下迭代结束
- 最多迭代次数为节点的个数

#### 无穷计数问题

- **触发更新(triggered update)**：不仅仅定期发送距离向量，在距离向量改变时立刻通知直接邻居，邻居再进一步传播开去
- **抑制（hold-down）机制**：
  - 路由器了解到某个网络不可达（距离为无穷大）时开启抑制计时器（抑制期）
  - 抑制期间，收到路由时：
    - 如果有一条比**抑制计时器开启前**的路径更好的路由，关闭计时器
    - 否则忽略收到的路由信息，即便其通知有一条到目的网络路由
  - 抑制期一般设为 60 秒，使得网络的不可达状态能传播到所有节点
  - 所有的路由器必须使用相同的抑制期，否则有可能发生路由回路
  - 抑制机制避免了可能的路由回路，但是以增加收敛时间为代价
- **水平分割**：通过一个特定的网络接口 X 发送距离向量时，绝对不要包括通过那个网络接口学习到的路由信息（即下一跳为接口 X 上的邻居路由器的距离向量）
- **带反向抑制的水平分割**（split horizon with poisoned reverse）
  - 给邻居路由器发送路由信息时将那些从该邻居了解到的路由信息的距离设为无穷大
  - 相比水平分割路由消息更大一些
  - 尽管有水平分割，仍然可能会出现两个节点之间的路由回路
  - 通过反向抑制可以更快地消除两个节点之间的路由回路，而不是等待超时而消除
